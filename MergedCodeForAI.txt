<file path="D:\Parsa Stuff\Visual Studio\BitwardenDecrypt\BitwardenDecrypt\Source\AccountInfo.cs">
namespace BitwardenDecryptor.Models;

public record AccountInfo(string Uuid, string Email);
</file>

<file path="D:\Parsa Stuff\Visual Studio\BitwardenDecrypt\BitwardenDecrypt\Source\BitwardenSecrets.cs">
namespace BitwardenDecryptor.Models;

public class BitwardenSecrets
{
    public string Email { get; set; } = string.Empty;
    public byte[] MasterPasswordBytes { get; set; } = [];
    public int KdfIterations { get; set; }
    public int? KdfMemory { get; set; }
    public int? KdfParallelism { get; set; }
    public int KdfType { get; set; }
    public string ProtectedSymmetricKeyCipherString { get; set; } = string.Empty;
    public string? ProtectedRsaPrivateKeyCipherString { get; set; }

    public byte[] MasterKey { get; set; } = [];
    public string MasterPasswordHash { get; set; } = string.Empty;

    public byte[] StretchedEncryptionKey { get; set; } = [];
    public byte[] StretchedMacKey { get; set; } = [];

    public byte[] GeneratedSymmetricKey { get; set; } = [];
    public byte[] GeneratedEncryptionKey { get; set; } = [];
    public byte[] GeneratedMacKey { get; set; } = [];

    public byte[]? RsaPrivateKeyDer { get; set; }

    public Dictionary<string, byte[]> OrganizationKeys { get; } = [];
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\BitwardenDecrypt\BitwardenDecrypt\Source\CommandLineOptions.cs">
namespace BitwardenDecryptor;

public class CommandLineOptions
{
    public string InputFile { get; set; } = "data.json";
    public bool IncludeSends { get; set; } = false;
    public string? OutputFile { get; set; }

    public string AccountUuid { get; set; } = string.Empty;
    public string AccountEmail { get; set; } = string.Empty;
    public string FileFormat { get; set; } = string.Empty;
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\BitwardenDecrypt\BitwardenDecrypt\Source\ConsolePasswordReader.cs">
using System.Text;

namespace BitwardenDecryptor.Utils;

public static class ConsolePasswordReader
{
    public static string ReadPassword(string prompt)
    {
        Console.Write(prompt);

        StringBuilder password = new();

        while (true)
        {
            ConsoleKeyInfo keyInfo = Console.ReadKey(true);

            if (keyInfo.Key == ConsoleKey.Enter)
            {
                Console.WriteLine();
                break;
            }

            if (keyInfo.Key == ConsoleKey.Backspace && password.Length > 0)
            {
                password.Remove(password.Length - 1, 1);
            }
            else if (!char.IsControl(keyInfo.KeyChar))
            {
                password.Append(keyInfo.KeyChar);
            }
        }

        return password.ToString();
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\BitwardenDecrypt\BitwardenDecrypt\Source\DecryptionResult.cs">
namespace BitwardenDecryptor.Models;

public record DecryptionResult(byte[]? Plaintext, string? Error);
</file>

<file path="D:\Parsa Stuff\Visual Studio\BitwardenDecrypt\BitwardenDecrypt\Source\Program.cs">
using System;
using System.CommandLine;
using System.IO;
using BitwardenDecryptor.Core;

namespace BitwardenDecryptor;

public static class Program
{
    public static int Main(string[] args)
    {
        RootCommand rootCommand = new("Decrypts an encrypted Bitwarden data.json file.");

        Argument<string> inputFileArgument = new(
            name: "inputfile",
            description: "Path to the Bitwarden data.json file.",
            getDefaultValue: () => "data.json");

        Option<bool> includeSendsOption = new(
            name: "--includesends",
            description: "Include Sends in the output.");

        Option<string?> outputFileOption = new(
            name: "--output",
            description: "Write decrypted output to file. Will overwrite if file exists.");

        Option<bool> saveOption = new(
            name: "--save",
            description: "Save the decrypted output to a file with a default name (e.g., 'data.json' becomes 'data.decrypted.json'). This is ignored if --output is used.");
        saveOption.AddAlias("-s");

        rootCommand.AddArgument(inputFileArgument);
        rootCommand.AddOption(includeSendsOption);
        rootCommand.AddOption(outputFileOption);
        rootCommand.AddOption(saveOption);

        rootCommand.SetHandler((inputFile, includeSends, outputFile, save) =>
        {
            try
            {
                string? finalOutputFile = outputFile;
                if (save && string.IsNullOrEmpty(finalOutputFile))
                {
                    string? directory = Path.GetDirectoryName(inputFile);
                    string filenameWithoutExt = Path.GetFileNameWithoutExtension(inputFile);
                    string newFilename = $"{filenameWithoutExt}.decrypted.json";
                    finalOutputFile = string.IsNullOrEmpty(directory)
                        ? newFilename
                        : Path.Combine(directory, newFilename);
                }

                CommandLineOptions options = new()
                {
                    InputFile = inputFile,
                    IncludeSends = includeSends,
                    OutputFile = finalOutputFile
                };

                RunDecryption(options);
            }
            catch (Exception ex)
            {
                Console.Error.WriteLine("\nAn unexpected error occurred:");
                Console.Error.WriteLine($"ERROR: {ex.Message}");
                Console.Error.WriteLine("\nPlease report this issue if you believe it's a bug.");
                Environment.ExitCode = 1;
            }
        }, 
        inputFileArgument,
        includeSendsOption,
        outputFileOption,
        saveOption);

        return rootCommand.Invoke(args);
    }

    private static void RunDecryption(CommandLineOptions options)
    {
        Console.WriteLine();

        if (!string.IsNullOrEmpty(options.OutputFile))
        {
            Console.WriteLine(File.Exists(options.OutputFile)
                ? $"Saving Output To: {options.OutputFile} (File Exists, Will Be Overwritten)\n"
                : $"Saving Output To: {options.OutputFile}\n");
        }

        Core.BitwardenDecryptor decryptor = new(options);
        string? decryptedJson = decryptor.DecryptBitwardenJson();

        if (decryptedJson == null)
        {
            Console.Error.WriteLine("Decryption failed. No output generated.");
            Environment.ExitCode = 1;
            return;
        }

        if (!string.IsNullOrEmpty(options.OutputFile))
        {
            try
            {
                File.WriteAllText(options.OutputFile, decryptedJson, System.Text.Encoding.UTF8);
                Console.WriteLine($"Successfully wrote decrypted data to {options.OutputFile}");
            }
            catch (Exception ex)
            {
                Console.Error.WriteLine($"ERROR: Writing to {options.OutputFile} - {ex.Message}");
                Environment.ExitCode = 1;
            }
        }
        else
        {
            Console.WriteLine(decryptedJson);
        }
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\BitwardenDecrypt\BitwardenDecrypt\Source\SymmetricKeyDecryptionResult.cs">
namespace BitwardenDecryptor.Models;

public record SymmetricKeyDecryptionResult(byte[]? FullKey, byte[]? EncKey, byte[]? MacKey, string? Error);
</file>

<file path="D:\Parsa Stuff\Visual Studio\BitwardenDecrypt\BitwardenDecrypt\Source\VaultFileParser.cs">
using System.Text.Json.Nodes;
using BitwardenDecryptor.Models;
using BitwardenDecryptor.Utils;

namespace BitwardenDecryptor.Core;

public static class VaultFileParser
{
    private record KdfAndKeyParameters(string EmailOrSalt, int KdfIterations, int? KdfMemory, int? KdfParallelism, int KdfType, string ProtectedSymmKey, string? EncPrivateKey);

    public static VaultMetadata? Parse(JsonNode rootNode, string inputFile)
    {
        VaultMetadata? result = TryParseEncryptedJsonFormat(rootNode)
            ?? TryParse2024Format(rootNode, inputFile)
            ?? TryParseNewFormat(rootNode, inputFile)
            ?? TryParseOldFormat(rootNode);

        if (result is not null)
        {
            return result;
        }

        Console.Error.WriteLine("\nERROR: Could not determine the format of the provided JSON file or find any account data within it.");
        Console.Error.WriteLine("Please ensure this is a valid Bitwarden `data.json` export file.");
        Console.Error.WriteLine("The file may be in an unsupported format, corrupted, or not a Bitwarden export at all.");
        
        return null;
    }

    private static VaultMetadata? TryParseEncryptedJsonFormat(JsonNode rootNode)
    {
        if (rootNode["encrypted"]?.GetValue<bool>() != true || rootNode["passwordProtected"]?.GetValue<bool>() != true)
        {
            return null;
        }

        string fileFormat = "EncryptedJSON";
        string emailOrSalt = rootNode["salt"]!.GetValue<string>();
        int kdfIterations = rootNode["kdfIterations"]!.GetValue<int>();
        int kdfType = rootNode["kdf"]?.GetValue<int>() ?? 0;
        string protectedSymmKeyOrValidation = rootNode["encKeyValidation_DO_NOT_EDIT"]!.GetValue<string>();

        return new(
            fileFormat,
            emailOrSalt,
            kdfIterations,
            null,
            null,
            kdfType,
            protectedSymmKeyOrValidation,
            null);
    }

    private static List<AccountInfo> Extract2024FormatAccounts(JsonObject accountsNode)
    {
        return accountsNode
            .Where(kvp => Guid.TryParse(kvp.Key, out _) && kvp.Value != null && kvp.Value.AsObject().Count != 0)
            .Select(kvp => new AccountInfo(kvp.Key, kvp.Value!["email"]!.GetValue<string>()))
            .ToList();
    }

    private static KdfAndKeyParameters GetKdfAndKeyParametersFor2024Format(JsonNode rootNode, string accountUuid, string accountEmail)
    {
        string emailOrSalt = accountEmail;
        JsonNode kdfConfigNode = rootNode[$"user_{accountUuid}_kdfConfig_kdfConfig"]!;
        int kdfIterations = kdfConfigNode["iterations"]!.GetValue<int>();
        int? kdfMemory = kdfConfigNode["memory"]?.GetValue<int>();
        int? kdfParallelism = kdfConfigNode["parallelism"]?.GetValue<int>();
        int kdfType = kdfConfigNode["kdfType"]!.GetValue<int>();
        string protectedSymmKey = rootNode[$"user_{accountUuid}_masterPassword_masterKeyEncryptedUserKey"]!.GetValue<string>();
        string? encPrivateKey = rootNode[$"user_{accountUuid}_crypto_privateKey"]?.GetValue<string>();
        
        return new(
            emailOrSalt,
            kdfIterations,
            kdfMemory,
            kdfParallelism,
            kdfType,
            protectedSymmKey,
            encPrivateKey);
    }

    private static VaultMetadata? TryParse2024Format(JsonNode rootNode, string inputFile)
    {
        if (rootNode["global_account_accounts"] is not JsonObject accountsNode)
        {
            return null;
        }

        string fileFormat = "2024";
        List<AccountInfo> validAccounts = Extract2024FormatAccounts(accountsNode);

        AccountInfo? selectedAccount = AccountSelector.SelectAccount(validAccounts, inputFile);
        
        if (selectedAccount is null)
        {
            return null;
        }

        string selectedAccountUuid = selectedAccount.Uuid;
        string selectedAccountEmail = selectedAccount.Email;

        KdfAndKeyParameters kdfParams =
            GetKdfAndKeyParametersFor2024Format(rootNode, selectedAccountUuid, selectedAccountEmail);

        return new(
            fileFormat,
            kdfParams.EmailOrSalt,
            kdfParams.KdfIterations,
            kdfParams.KdfMemory,
            kdfParams.KdfParallelism,
            kdfParams.KdfType,
            kdfParams.ProtectedSymmKey,
            kdfParams.EncPrivateKey,
            selectedAccountEmail,
            selectedAccountUuid);
    }

    private static List<AccountInfo> ExtractNewFormatAccounts(JsonNode rootNode)
    {
        return rootNode.AsObject()
            .Where(kvp => Guid.TryParse(kvp.Key, out _) && kvp.Value?["profile"]?["email"] != null)
            .Select(kvp => new AccountInfo(kvp.Key, kvp.Value!["profile"]!["email"]!.GetValue<string>()))
            .ToList();
    }

    private static KdfAndKeyParameters GetKdfAndKeyParametersForNewFormat(JsonNode rootNode, string accountUuid, string accountEmail)
    {
        JsonNode accountNode = rootNode[accountUuid]!;
        string emailOrSalt = accountEmail;
        JsonNode profileNode = accountNode["profile"]!;
        int kdfIterations = profileNode["kdfIterations"]!.GetValue<int>();
        int? kdfMemory = profileNode["kdfMemory"]?.GetValue<int>();
        int? kdfParallelism = profileNode["kdfParallelism"]?.GetValue<int>();
        int kdfType = profileNode["kdfType"]!.GetValue<int>();
        JsonNode keysNode = accountNode["keys"]!;
        string protectedSymmKey = keysNode["masterKeyEncryptedUserKey"]?.GetValue<string>() ?? keysNode["cryptoSymmetricKey"]!["encrypted"]!.GetValue<string>();
        string? encPrivateKey = keysNode["privateKey"]!["encrypted"]!.GetValue<string>();
        
        return new(
            emailOrSalt,
            kdfIterations,
            kdfMemory,
            kdfParallelism,
            kdfType,
            protectedSymmKey,
            encPrivateKey);
    }

    private static VaultMetadata? TryParseNewFormat(JsonNode rootNode, string inputFile)
    {
        List<AccountInfo> potentialNewFormatAccounts = ExtractNewFormatAccounts(rootNode);

        if (potentialNewFormatAccounts.Count == 0)
        {
            return null;
        }

        string fileFormat = "NEW";

        var selectedAccount = AccountSelector.SelectAccount(potentialNewFormatAccounts, inputFile);
        if (selectedAccount is null)
        {
            return null;
        }
        string selectedAccountUuid = selectedAccount.Uuid;
        string selectedAccountEmail = selectedAccount.Email;

        KdfAndKeyParameters kdfParams =
            GetKdfAndKeyParametersForNewFormat(rootNode, selectedAccountUuid, selectedAccountEmail);

        return new(
            fileFormat,
            kdfParams.EmailOrSalt,
            kdfParams.KdfIterations,
            kdfParams.KdfMemory,
            kdfParams.KdfParallelism,
            kdfParams.KdfType,
            kdfParams.ProtectedSymmKey,
            kdfParams.EncPrivateKey,
            selectedAccountEmail,
            selectedAccountUuid);
    }

    private static KdfAndKeyParameters GetKdfAndKeyParametersForOldFormat(JsonNode rootNode, string accountEmail)
    {
        string emailOrSalt = accountEmail;
        int kdfIterations = rootNode["kdfIterations"]!.GetValue<int>();
        int kdfType = rootNode["kdf"]?.GetValue<int>() ?? 0;
        string protectedSymmKey = rootNode["encKey"]!.GetValue<string>();
        string? encPrivateKey = rootNode["encPrivateKey"]?.GetValue<string>();
        return new KdfAndKeyParameters(emailOrSalt, kdfIterations, null, null, kdfType, protectedSymmKey, encPrivateKey);
    }

    private static VaultMetadata? TryParseOldFormat(JsonNode rootNode)
    {
        if (rootNode["userEmail"] is null)
        {
            return null;
        }

        string fileFormat = "OLD";
        string accountUuid = rootNode["userId"]?.GetValue<string>() ?? string.Empty;
        string accountEmail = rootNode["userEmail"]!.GetValue<string>();

        KdfAndKeyParameters kdfParams =
            GetKdfAndKeyParametersForOldFormat(rootNode, accountEmail);

        return new(
            fileFormat,
            kdfParams.EmailOrSalt,
            kdfParams.KdfIterations,
            kdfParams.KdfMemory,
            kdfParams.KdfParallelism,
            kdfParams.KdfType,
            kdfParams.ProtectedSymmKey,
            kdfParams.EncPrivateKey,
            accountEmail,
            accountUuid);
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\BitwardenDecrypt\BitwardenDecrypt\Source\VaultMetadata.cs">
namespace BitwardenDecryptor.Core;

public class VaultMetadata
{
    public string FileFormat { get; }
    public string? AccountEmail { get; }
    public string? AccountUuid { get; }
    public string KdfSalt { get; }
    public int KdfIterations { get; }
    public int? KdfMemory { get; }
    public int? KdfParallelism { get; }
    public int KdfType { get; }
    public string ProtectedSymmetricKey { get; }
    public string? ProtectedRsaPrivateKey { get; }

    public VaultMetadata(
        string fileFormat,
        string kdfSalt,
        int kdfIterations,
        int? kdfMemory,
        int? kdfParallelism,
        int kdfType,
        string protectedSymmetricKey,
        string? protectedRsaPrivateKey,
        string? accountEmail = null,
        string? accountUuid = null)
    {
        FileFormat = fileFormat;
        KdfSalt = kdfSalt;
        KdfIterations = kdfIterations;
        KdfMemory = kdfMemory;
        KdfParallelism = kdfParallelism;
        KdfType = kdfType;
        ProtectedSymmetricKey = protectedSymmetricKey;
        ProtectedRsaPrivateKey = protectedRsaPrivateKey;
        AccountEmail = accountEmail;
        AccountUuid = accountUuid;
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\BitwardenDecrypt\BitwardenDecrypt\Source\Decryptors\BitwardenDecryptor.cs">
using System.Text.Encodings.Web;
using System.Text.Json;
using System.Text.Json.Nodes;
using BitwardenDecryptor.Models;
using BitwardenDecryptor.Utils;

namespace BitwardenDecryptor.Core;

public class BitwardenDecryptor(CommandLineOptions options)
{
    private readonly CommandLineOptions options = options;

    public string? DecryptBitwardenJson()
    {
        JsonNode? rootNode = LoadAndParseInputFile();
        
        if (rootNode is null)
        {
            return null;
        }

        VaultMetadata? metadata = VaultFileParser.Parse(rootNode, options.InputFile);
        
        if (metadata is null)
        {
            Environment.Exit(1);
            return null;
        }

        options.FileFormat = metadata.FileFormat;
        options.AccountEmail = metadata.AccountEmail ?? string.Empty;
        options.AccountUuid = metadata.AccountUuid ?? string.Empty;

        string password = GetPasswordFromUser(metadata);

        BitwardenSecrets secrets = KeyDerivationService.DeriveKeys(metadata, password);

        VaultDataDecryptor vaultDataDecryptor = new(secrets, options);
        JsonObject decryptedData = vaultDataDecryptor.DecryptVault(rootNode);

        JsonObject finalOutputObject = StructureOutputJson(decryptedData);

        JsonSerializerOptions jsonSerializerOptions = new()
        {
            WriteIndented = true,
            Encoder = JavaScriptEncoder.UnsafeRelaxedJsonEscaping
        };

        return finalOutputObject.ToJsonString(jsonSerializerOptions);
    }

    private JsonNode? LoadAndParseInputFile()
    {
        string jsonData;

        try
        {
            jsonData = File.ReadAllText(options.InputFile);
        }
        catch (FileNotFoundException)
        {
            Console.Error.WriteLine($"\nERROR: The input file '{options.InputFile}' was not found.");
            Console.Error.WriteLine("\nPlease check the following:");
            Console.Error.WriteLine($"  1. The file '{options.InputFile}' actually exists in the current directory.");
            Console.Error.WriteLine("  2. You have spelled the filename correctly.");
            Console.Error.WriteLine("  3. If the file is in a different directory, provide the full path to it.");
            Console.Error.WriteLine("     Example: bitwardendecrypt \"C:\\Users\\YourUser\\Downloads\\data.json\"");
            Environment.Exit(1);
            return null;
        }
        catch (Exception ex)
        {
            Console.Error.WriteLine($"ERROR: An error occurred reading: {options.InputFile} - {ex.Message}");
            Environment.Exit(1);
            return null;
        }

        try
        {
            return JsonNode.Parse(jsonData)!;
        }
        catch (JsonException ex)
        {
            Console.Error.WriteLine($"\nERROR: The file '{options.InputFile}' could not be read because it is not valid JSON.");
            Console.Error.WriteLine("Please ensure it is a proper, unmodified export from Bitwarden.");
            Console.Error.WriteLine($"Details: {ex.Message}");
            Environment.Exit(1);
            return null;
        }
    }

    private string GetPasswordFromUser(VaultMetadata metadata)
    {
        string passwordPromptDetail = metadata.FileFormat == "EncryptedJSON"
            ? $"Export Password (for salt: {metadata.KdfSalt})"
            : $"Master Password (for account: {metadata.AccountEmail})";

        return ConsolePasswordReader.ReadPassword($"Enter {passwordPromptDetail}: ");
    }

    private static JsonObject StructureOutputJson(JsonObject decryptedData)
    {
        JsonObject finalOutputObject = [];

        if (decryptedData.ContainsKey("folders"))
        {
            finalOutputObject["folders"] = decryptedData["folders"]!.DeepClone();
        }

        foreach (KeyValuePair<string, JsonNode?> prop in decryptedData)
        {
            if (prop.Key == "folders" || prop.Key == "sends")
            {
                continue;
            }

            finalOutputObject[prop.Key] = prop.Value!.DeepClone();
        }

        if (decryptedData.ContainsKey("sends"))
        {
            finalOutputObject["sends"] = decryptedData["sends"]!.DeepClone();
        }

        return finalOutputObject;
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\BitwardenDecrypt\BitwardenDecrypt\Source\Decryptors\ProtectedKeyDecryptor.cs">
using BitwardenDecryptor.Crypto;
using BitwardenDecryptor.Models;

namespace BitwardenDecryptor.Core;

public static class ProtectedKeyDecryptor
{
    public static SymmetricKeyDecryptionResult DecryptSymmetricKey(string cipherString, byte[] masterKey, byte[] masterMacKey, bool isExportValidationKey = false)
    {
        if (string.IsNullOrEmpty(cipherString))
        {
            return new SymmetricKeyDecryptionResult(null, null, null, "CipherString is empty.");
        }

        string[] parts = cipherString.Split('.');

        if (parts.Length < 2)
        {
            return new SymmetricKeyDecryptionResult(null, null, null, "Invalid CipherString format.");
        }

        if (!int.TryParse(parts[0], out int encType))
        {
            return new SymmetricKeyDecryptionResult(null, null, null, "Invalid encryption type in CipherString.");
        }

        DecryptionResult decryptionResult = CryptoService.VerifyAndDecryptAesCbc(masterKey, masterMacKey, cipherString);

        if (decryptionResult.Error != null || decryptionResult.Plaintext == null)
        {
            return new SymmetricKeyDecryptionResult(null, null, null, decryptionResult.Error);
        }

        byte[] cleartextBytes = decryptionResult.Plaintext;

        if (!isExportValidationKey && encType == 2 && cleartextBytes.Length < 64)
        {
            return new SymmetricKeyDecryptionResult(null, null, null, "Decrypted key is too short. Likely wrong password (for data.json user key).");
        }

        if ((encType == 2 || encType == 0) && cleartextBytes.Length >= 64)
        {
            byte[] enc = cleartextBytes.Take(32).ToArray();
            byte[] mac = cleartextBytes.Skip(32).Take(32).ToArray();
            return new SymmetricKeyDecryptionResult(cleartextBytes, enc, mac, null);
        }

        return new SymmetricKeyDecryptionResult(cleartextBytes, null, null, null);
    }

    public static byte[]? DecryptRsaPrivateKeyBytes(string cipherString, byte[] encryptionKey, byte[] macKey)
    {
        DecryptionResult result = CryptoService.VerifyAndDecryptAesCbc(encryptionKey, macKey, cipherString);

        if (result.Error != null)
        {
            Console.Error.WriteLine($"ERROR decrypting RSA private key wrapper: {result.Error}");
            return null;
        }

        return result.Plaintext;
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\BitwardenDecrypt\BitwardenDecrypt\Source\Decryptors\VaultDataDecryptor.cs">
using System.Text.Json.Nodes;
using BitwardenDecryptor.Core.VaultStrategies;
using BitwardenDecryptor.Models;

namespace BitwardenDecryptor.Core;

public class VaultDataDecryptor(BitwardenSecrets secrets, CommandLineOptions options)
{
    public JsonObject DecryptVault(JsonNode rootNode)
    {
        IVaultDecryptorStrategy strategy = CreateStrategy(rootNode);
        return strategy.Decrypt();
    }

    private IVaultDecryptorStrategy CreateStrategy(JsonNode rootNode)
    {
        var vaultItemDecryptor = new VaultItemDecryptor(secrets);

        return options.FileFormat switch
        {
            "EncryptedJSON" => new EncryptedJsonDecryptorStrategy(rootNode, secrets, vaultItemDecryptor),
            "2024" => new Format2024DecryptorStrategy(rootNode, secrets, options, vaultItemDecryptor),
            "NEW" or "OLD" => new LegacyJsonDecryptorStrategy(rootNode, secrets, options, vaultItemDecryptor),
            _ => throw new NotSupportedException($"The file format '{options.FileFormat}' is not supported.")
        };
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\BitwardenDecrypt\BitwardenDecrypt\Source\Decryptors\VaultItemDecryptor.cs">
using System.Security.Cryptography;
using System.Text;
using System.Text.Json;
using System.Text.Json.Nodes;
using System.Text.RegularExpressions;
using BitwardenDecryptor.Crypto;
using BitwardenDecryptor.Models;

namespace BitwardenDecryptor.Core;

public class VaultItemDecryptor(BitwardenSecrets secrets)
{
    private static readonly Regex CipherStringRegex = new(@"\d.[^,]+|[^,]+=[^""]*", RegexOptions.Compiled);

    public string DecryptCipherString(string cipherString, byte[] encryptionKey, byte[] macKey)
    {
        if (string.IsNullOrEmpty(cipherString))
        {
            return string.Empty;
        }

        string[] parts = cipherString.Split('.');

        if (parts.Length < 2)
        {
            return $"ERROR Decrypting: Invalid CipherString format {cipherString}";
        }

        if (!int.TryParse(parts[0], out _))
        {
            return $"ERROR Decrypting: Invalid encType {cipherString}";
        }

        DecryptionResult decryptionResult = CryptoService.VerifyAndDecryptAesCbc(encryptionKey, macKey, cipherString);

        if (decryptionResult.Error != null || decryptionResult.Plaintext == null)
        {
            return $"ERROR: {decryptionResult.Error}. CipherString not decrypted: {cipherString}";
        }

        try
        {
            return Encoding.UTF8.GetString(decryptionResult.Plaintext);
        }
        catch (DecoderFallbackException)
        {
            if (secrets.GeneratedEncryptionKey.Length == 0 || secrets.GeneratedMacKey.Length == 0)
            {
                return $"ERROR Decrypting (UTF-8 decode failed, fallback keys unavailable): {cipherString}";
            }

            SymmetricKeyDecryptionResult fallbackResult = ProtectedKeyDecryptor.DecryptSymmetricKey(cipherString, secrets.GeneratedEncryptionKey, secrets.GeneratedMacKey);

            if (fallbackResult.Error is null && fallbackResult.FullKey is not null)
            {
                return BitConverter.ToString(fallbackResult.FullKey).Replace("-", "").ToLowerInvariant();
            }

            return $"ERROR Decrypting (UTF-8 decode failed, fallback also failed): {cipherString}";
        }
    }

    public byte[]? DecryptRsaInternal(string cipherString)
    {
        if (secrets.RsaPrivateKeyDer is null)
        {
            Console.Error.WriteLine($"Cannot decrypt RSA cipher string as private key is not available.");
            return null;
        }

        string[] parts = cipherString.Split('.');

        if (parts.Length < 2)
        {
            Console.Error.WriteLine($"Invalid RSA CipherString format: {cipherString}");
            return null;
        }

        string[] dataParts = parts[1].Split('|');

        if (dataParts.Length < 1)
        {
            Console.Error.WriteLine($"Invalid RSA CipherString data part: {cipherString}");
            return null;
        }

        byte[] ciphertext;

        try
        {
            ciphertext = Convert.FromBase64String(dataParts[0]);
        }
        catch (FormatException ex)
        {
            Console.Error.WriteLine($"Base64 decoding failed for RSA ciphertext: {ex.Message}");
            return null;
        }

        return CryptoService.DecryptRsaOaepSha1(secrets.RsaPrivateKeyDer, ciphertext);
    }

    public JsonNode? DecryptSend(JsonNode sendNode)
    {
        string? keyCipherString = sendNode["key"]?.GetValue<string>();

        if (keyCipherString is null)
        {
            return sendNode;
        }

        if (secrets.GeneratedEncryptionKey.Length == 0 || secrets.GeneratedMacKey.Length == 0)
        {
            Console.Error.WriteLine($"ERROR: Cannot decrypt Send key as user symmetric keys are not fully available.");
            sendNode["key"] = $"ERROR: Cannot decrypt Send key - user keys unavailable.";
            return sendNode;
        }

        SymmetricKeyDecryptionResult sendKeyResult = ProtectedKeyDecryptor.DecryptSymmetricKey(keyCipherString, secrets.GeneratedEncryptionKey, secrets.GeneratedMacKey);

        if (sendKeyResult.Error is not null || sendKeyResult.FullKey is null)
        {
            Console.Error.WriteLine($"Failed to decrypt Send key: {sendKeyResult.Error}");
            sendNode["key"] = $"ERROR: Failed to decrypt Send key - {sendKeyResult.Error}";
            return sendNode;
        }

        byte[] salt = Encoding.UTF8.GetBytes("bitwarden-send");
        byte[] info = Encoding.UTF8.GetBytes("send");
        byte[] derivedSendKeyMaterial = HKDF.DeriveKey(HashAlgorithmName.SHA256, sendKeyResult.FullKey, 64, salt, info);

        byte[] sendEncKey = derivedSendKeyMaterial.Take(32).ToArray();
        byte[] sendMacKey = derivedSendKeyMaterial.Skip(32).Take(32).ToArray();

        sendNode["key"] = BitConverter.ToString(derivedSendKeyMaterial).Replace("-", "").ToLowerInvariant();

        string sendJsonString = sendNode.ToJsonString();
        MatchCollection matches = CipherStringRegex.Matches(sendJsonString);

        foreach (Match match in matches.Reverse())
        {
            string decryptedValue = DecryptCipherString(match.Value, sendEncKey, sendMacKey);
            string jsonEscapedValue = JsonSerializer.Serialize(decryptedValue);

            if (jsonEscapedValue.Length >= 2)
            {
                jsonEscapedValue = jsonEscapedValue[1..^1];
            }

            sendJsonString = sendJsonString.Remove(match.Index, match.Length).Insert(match.Index, jsonEscapedValue);
        }

        return JsonNode.Parse(sendJsonString);
    }

    public JsonObject ProcessGroupItem(JsonNode groupItemNode)
    {
        string? orgId = groupItemNode["organizationId"]?.GetValue<string>();
        byte[] itemEncKey;
        byte[] itemMacKey;

        if (orgId != null && secrets.OrganizationKeys.TryGetValue(orgId, out byte[]? orgFullKey) && orgFullKey != null && orgFullKey.Length >= 64)
        {
            itemEncKey = orgFullKey.Take(32).ToArray();
            itemMacKey = orgFullKey.Skip(32).Take(32).ToArray();
        }
        else
        {
            if (secrets.GeneratedEncryptionKey.Length == 0 || secrets.GeneratedMacKey.Length == 0)
            {
                Console.Error.WriteLine($"Warning: User symmetric keys not fully available for item {groupItemNode["id"]?.GetValue<string>()}. Defaulting to stretched keys; decryption may fail for some fields.");
                itemEncKey = secrets.StretchedEncryptionKey;
                itemMacKey = secrets.StretchedMacKey;
            }
            else
            {
                itemEncKey = secrets.GeneratedEncryptionKey;
                itemMacKey = secrets.GeneratedMacKey;
            }
        }

        string? individualItemKeyCipherString = groupItemNode["key"]?.GetValue<string>();

        if (!string.IsNullOrEmpty(individualItemKeyCipherString))
        {
            SymmetricKeyDecryptionResult itemKeyResult = ProtectedKeyDecryptor.DecryptSymmetricKey(individualItemKeyCipherString, itemEncKey, itemMacKey);

            if (itemKeyResult.Error is null && itemKeyResult.EncKey is not null && itemKeyResult.MacKey is not null)
            {
                itemEncKey = itemKeyResult.EncKey;
                itemMacKey = itemKeyResult.MacKey;

                if (groupItemNode is JsonObject obj)
                {
                    obj["key"] = "";
                }
            }
            else if (itemKeyResult.Error is not null && groupItemNode is JsonObject obj)
            {
                obj["key"] = $"ERROR: Could not decrypt item key. {itemKeyResult.Error}";
            }
        }

        string itemJsonString = groupItemNode.ToJsonString();
        MatchCollection matches = CipherStringRegex.Matches(itemJsonString);

        foreach (Match? match in matches.Reverse())
        {
            if (match is null)
            {
                continue;
            }

            string decryptedValue = DecryptCipherString(match.Value, itemEncKey, itemMacKey);
            string jsonEscapedValue = JsonSerializer.Serialize(decryptedValue);

            if (jsonEscapedValue.Length >= 2)
            {
                jsonEscapedValue = jsonEscapedValue[1..^1];
            }

            itemJsonString = itemJsonString.Remove(match.Index, match.Length).Insert(match.Index, jsonEscapedValue);
        }

        JsonObject processedNode = JsonNode.Parse(itemJsonString)!.AsObject();
        string[] userIdKeys = ["userId", "organizationUserId"];

        foreach (string key in userIdKeys)
        {
            if (!processedNode.ContainsKey(key))
            {
                continue;
            }

            processedNode.Remove(key);
        }

        return processedNode;
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\BitwardenDecrypt\BitwardenDecrypt\Source\Services\CryptoService.cs">
using System.Security.Cryptography;
using BitwardenDecryptor.Models;
using Isopoh.Cryptography.Argon2;
using Isopoh.Cryptography.SecureArray;

namespace BitwardenDecryptor.Crypto;

public static class CryptoService
{
    public static byte[] DerivePbkdf2Sha256(byte[] password, byte[] salt, int iterations, int outputLength)
    {
        using Rfc2898DeriveBytes pbkdf2 = new(password, salt, iterations, HashAlgorithmName.SHA256);
        return pbkdf2.GetBytes(outputLength);
    }

    public static byte[] DeriveArgon2id(byte[] password, byte[] salt, int iterations, int memoryKiB, int parallelism, int outputLength)
    {
        Argon2Config config = new()
        {
            Type = Argon2Type.HybridAddressing,
            Version = Argon2Version.Nineteen,
            TimeCost = iterations,
            MemoryCost = memoryKiB,
            Lanes = parallelism,
            Threads = parallelism,
            Password = password,
            Salt = salt,
            HashLength = outputLength
        };

        using Argon2 argon2 = new(config);
        using SecureArray<byte> hashResult = argon2.Hash();
        return hashResult.Buffer;
    }

    public static byte[] HkdfExpandSha256(byte[] ikm, byte[] info, int outputLength)
    {
        return HKDF.Expand(HashAlgorithmName.SHA256, ikm, outputLength, info);
    }

    public static byte[] ComputeHmacSha256(byte[] key, byte[] data)
    {
        using HMACSHA256 hmac = new(key);
        return hmac.ComputeHash(data);
    }

    public static byte[]? DecryptAesCbc(byte[] key, byte[] iv, byte[] ciphertext, PaddingMode paddingMode = PaddingMode.PKCS7)
    {
        using Aes aes = Aes.Create();

        if (aes is null)
        {
            return null;
        }

        aes.KeySize = 256;
        aes.BlockSize = 128;
        aes.Mode = CipherMode.CBC;
        aes.Padding = paddingMode;
        aes.Key = key;
        aes.IV = iv;

        using ICryptoTransform decryptor = aes.CreateDecryptor(aes.Key, aes.IV);
        using MemoryStream msDecrypt = new(ciphertext);
        using CryptoStream csDecrypt = new(msDecrypt, decryptor, CryptoStreamMode.Read);
        using MemoryStream msPlain = new();
        csDecrypt.CopyTo(msPlain);

        return msPlain.ToArray();
    }

    public static DecryptionResult VerifyAndDecryptAesCbc(byte[] encryptionKey, byte[] macKey, string cipherString)
    {
        string[] parts = cipherString.Split('.');

        if (parts.Length < 2)
        {
            return new DecryptionResult(null, "Invalid CipherString format (missing type or data).");
        }

        string[] dataParts = parts[1].Split('|');

        if (dataParts.Length < 3)
        {
            return new DecryptionResult(null, "Invalid CipherString format (missing IV, ciphertext, or MAC).");
        }

        byte[] iv;
        byte[] ciphertext;
        byte[] mac;

        try
        {
            iv = Convert.FromBase64String(dataParts[0]);
            ciphertext = Convert.FromBase64String(dataParts[1]);
            mac = Convert.FromBase64String(dataParts[2]);
        }
        catch (FormatException ex)
        {
            return new DecryptionResult(null, $"Base64 decoding failed: {ex.Message}");
        }

        byte[] dataToMac = [.. iv, .. ciphertext];
        byte[] calculatedMac = ComputeHmacSha256(macKey, dataToMac);

        if (!mac.SequenceEqual(calculatedMac))
        {
            return new DecryptionResult(null, "MAC mismatch.");
        }

        try
        {
            byte[]? decrypted = DecryptAesCbc(encryptionKey, iv, ciphertext);
            return new DecryptionResult(decrypted, null);
        }
        catch (CryptographicException ex)
        {
            return new DecryptionResult(null, $"Decryption failed (possibly wrong password/key or padding): {ex.Message}");
        }
    }

    public static byte[]? DecryptRsaOaepSha1(byte[] privateKeyDer, byte[] ciphertext)
    {
        try
        {
            using RSA rsa = RSA.Create();

            if (rsa == null)
            {
                return null;
            }

            try
            {
                rsa.ImportPkcs8PrivateKey(privateKeyDer, out _);
            }
            catch (CryptographicException)
            {
                try
                {
                    rsa.ImportRSAPrivateKey(privateKeyDer, out _);
                }
                catch (CryptographicException ex)
                {
                    Console.Error.WriteLine($"Failed to import RSA private key (DER): {ex.Message}");
                    return null;
                }
            }

            return rsa.Decrypt(ciphertext, RSAEncryptionPadding.OaepSHA1);
        }
        catch (CryptographicException ex)
        {
            Console.Error.WriteLine($"RSA decryption failed: {ex.Message}");
            return null;
        }
    }

    public static byte[] Sha256Hash(byte[] data)
    {
        return SHA256.HashData(data);
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\BitwardenDecrypt\BitwardenDecrypt\Source\Services\KeyDerivationService.cs">
using System.Text;
using BitwardenDecryptor.Crypto;
using BitwardenDecryptor.Models;

namespace BitwardenDecryptor.Core;

public class KeyDerivationService
{
    public static BitwardenSecrets DeriveKeys(VaultMetadata metadata, string password)
    {
        BitwardenSecrets secrets = InitializeSecrets(metadata, password);
        byte[] kdfSaltInput = Encoding.UTF8.GetBytes(metadata.KdfSalt);

        DeriveMasterKey(secrets, kdfSaltInput);
        DeriveMasterPasswordHash(secrets);
        DeriveStretchedKeys(secrets);
        DecryptAndSetSymmetricKeys(secrets, metadata.FileFormat);
        DecryptAndSetRsaPrivateKey(secrets);

        return secrets;
    }

    private static BitwardenSecrets InitializeSecrets(VaultMetadata metadata, string password)
    {
        return new()
        {
            Email = metadata.AccountEmail ?? metadata.KdfSalt,
            MasterPasswordBytes = Encoding.UTF8.GetBytes(password),
            KdfIterations = metadata.KdfIterations,
            KdfMemory = metadata.KdfMemory,
            KdfParallelism = metadata.KdfParallelism,
            KdfType = metadata.KdfType,
            ProtectedSymmetricKeyCipherString = metadata.ProtectedSymmetricKey,
            ProtectedRsaPrivateKeyCipherString = metadata.ProtectedRsaPrivateKey
        };
    }

    private static void DeriveMasterKey(BitwardenSecrets secrets, byte[] kdfSaltInput)
    {
        if (secrets.KdfType == 1) // Argon2id
        {
            DeriveMasterKeyWithArgon2id(secrets);
        }
        else // PBKDF2
        {
            DeriveMasterKeyWithPbkdf2(secrets, kdfSaltInput);
        }
    }

    private static void DeriveMasterKeyWithArgon2id(BitwardenSecrets secrets)
    {
        if (!secrets.KdfMemory.HasValue || !secrets.KdfParallelism.HasValue)
        {
            Console.Error.WriteLine("ERROR: KDF memory or parallelism not set for Argon2id.");
            Environment.Exit(1);
        }

        byte[] argonSalt = CryptoService.Sha256Hash(Encoding.UTF8.GetBytes(secrets.Email));
        secrets.MasterKey = CryptoService.DeriveArgon2id(
            secrets.MasterPasswordBytes,
            argonSalt,
            secrets.KdfIterations,
            secrets.KdfMemory.Value * 1024, // KDFMemory is in KiB, Argon2 expects bytes
            secrets.KdfParallelism.Value,
            32); // 32 bytes for master key
    }

    private static void DeriveMasterKeyWithPbkdf2(BitwardenSecrets secrets, byte[] kdfSaltInput)
    {
        secrets.MasterKey = CryptoService.DerivePbkdf2Sha256(
           secrets.MasterPasswordBytes,
           kdfSaltInput,
           secrets.KdfIterations,
           32); // 32 bytes for master key
    }

    private static void DeriveMasterPasswordHash(BitwardenSecrets secrets)
    {
        byte[] masterPasswordHashDerived = CryptoService.DerivePbkdf2Sha256(secrets.MasterKey, secrets.MasterPasswordBytes, 1, 32);
        secrets.MasterPasswordHash = Convert.ToBase64String(masterPasswordHashDerived);
    }

    private static void DeriveStretchedKeys(BitwardenSecrets secrets)
    {
        secrets.StretchedEncryptionKey = CryptoService.HkdfExpandSha256(secrets.MasterKey, Encoding.UTF8.GetBytes("enc"), 32);
        secrets.StretchedMacKey = CryptoService.HkdfExpandSha256(secrets.MasterKey, Encoding.UTF8.GetBytes("mac"), 32);
    }

    private static void DecryptAndSetSymmetricKeys(BitwardenSecrets secrets, string fileFormat)
    {
        bool isForExportValidation = fileFormat == "EncryptedJSON";
        SymmetricKeyDecryptionResult result = ProtectedKeyDecryptor.DecryptSymmetricKey(
            secrets.ProtectedSymmetricKeyCipherString,
            secrets.StretchedEncryptionKey,
            secrets.StretchedMacKey,
            isForExportValidation);

        HandleSymmetricKeyDecryptionResult(result.Error, result.FullKey);

        // At this point, symKey is guaranteed to be non-null if HandleSymmetricKeyDecryptionResult did not exit.
        secrets.GeneratedSymmetricKey = result.FullKey!;
        secrets.GeneratedEncryptionKey = result.EncKey ?? [];
        secrets.GeneratedMacKey = result.MacKey ?? [];
    }

    private static void HandleSymmetricKeyDecryptionResult(string? error, byte[]? symKey)
    {
        if (error != null || symKey == null)
        {
            string errorMessageToDisplay = error ?? "Symmetric key is null after decryption without explicit error.";
            Console.Error.WriteLine($"ERROR: Failed to decrypt/validate Protected Symmetric Key or Export Validation Key. {errorMessageToDisplay}");

            if (error != null &&
                (error.Contains("MAC mismatch", StringComparison.OrdinalIgnoreCase) ||
                 error.Contains("padding", StringComparison.OrdinalIgnoreCase) ||
                 error.Contains("Likely wrong password", StringComparison.OrdinalIgnoreCase)))
            {
                Console.Error.WriteLine("This often indicates a wrong password (either Master Password for data.json or Export Password for encrypted exports).");
            }
            else if (symKey == null && error == null)
            {
                Console.Error.WriteLine("This might indicate an unexpected issue with the decrypted data structure or a problem not caught by specific error checks.");
            }

            Environment.Exit(1);
        }
    }

    private static void DecryptAndSetRsaPrivateKey(BitwardenSecrets secrets)
    {
        if (string.IsNullOrEmpty(secrets.ProtectedRsaPrivateKeyCipherString))
        {
            return;
        }

        if (secrets.GeneratedEncryptionKey.Length == 0 || secrets.GeneratedMacKey.Length == 0)
        {
            Console.Error.WriteLine("ERROR: Cannot decrypt RSA private key because dependent symmetric keys were not properly derived.");
            return;
        }

        secrets.RsaPrivateKeyDer = ProtectedKeyDecryptor.DecryptRsaPrivateKeyBytes(
            secrets.ProtectedRsaPrivateKeyCipherString,
            secrets.GeneratedEncryptionKey,
            secrets.GeneratedMacKey);

        if (secrets.RsaPrivateKeyDer is null)
        {
            Console.Error.WriteLine("ERROR: Failed to decrypt RSA Private Key.");
        }
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\BitwardenDecrypt\BitwardenDecrypt\Source\Utils\AccountSelector.cs">
using BitwardenDecryptor.Models;

namespace BitwardenDecryptor.Utils;

public static class AccountSelector
{
    public static AccountInfo? SelectAccount(IReadOnlyList<AccountInfo> accounts, string inputFile)
    {
        if (accounts.Count == 0)
        {
            Console.Error.WriteLine($"ERROR: No Accounts Found In {inputFile}");
            return null;
        }

        if (accounts.Count == 1)
        {
            return accounts[0];
        }

        Console.WriteLine("Which Account Would You Like To Decrypt?");

        for (int i = 0; i < accounts.Count; i++)
        {
            Console.WriteLine($" {i + 1}:\t{accounts[i].Email}");
        }

        int choice = 0;

        Console.WriteLine();

        while (choice < 1 || choice > accounts.Count)
        {
            Console.Write("Enter Number: ");

            if (!int.TryParse(Console.ReadLine(), out choice))
            {
                choice = 0;
            }
        }

        Console.WriteLine();

        return accounts[choice - 1];
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\BitwardenDecrypt\BitwardenDecrypt\Source\Decryptors\VaultStrategies\EncryptedJsonDecryptorStrategy.cs">
using System.Text.Json.Nodes;
using BitwardenDecryptor.Models;

namespace BitwardenDecryptor.Core.VaultStrategies;

public class EncryptedJsonDecryptorStrategy(
    JsonNode rootNode,
    BitwardenSecrets secrets,
    VaultItemDecryptor vaultItemDecryptor) : IVaultDecryptorStrategy
{
    public JsonObject Decrypt()
    {
        string? encryptedVaultData = rootNode["data"]?.GetValue<string>();

        if (string.IsNullOrEmpty(encryptedVaultData))
        {
            Console.Error.WriteLine("ERROR: No vault data found in EncryptedJSON export.");
            Environment.Exit(1);
        }

        string decryptedJsonPayload = vaultItemDecryptor.DecryptCipherString(encryptedVaultData, secrets.StretchedEncryptionKey, secrets.StretchedMacKey);

        if (decryptedJsonPayload.StartsWith("ERROR"))
        {
            Console.Error.WriteLine($"ERROR: Failed to decrypt EncryptedJSON payload. {decryptedJsonPayload}");
            Environment.Exit(1);
        }

        JsonObject payloadNode = JsonNode.Parse(decryptedJsonPayload)!.AsObject();
        JsonObject decryptedEntries = [];
        foreach (KeyValuePair<string, JsonNode?> prop in payloadNode)
        {
            decryptedEntries[prop.Key] = prop.Value?.DeepClone();
        }
        
        return decryptedEntries;
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\BitwardenDecrypt\BitwardenDecrypt\Source\Decryptors\VaultStrategies\Format2024DecryptorStrategy.cs">
using System.Text.Json.Nodes;
using BitwardenDecryptor.Models;

namespace BitwardenDecryptor.Core.VaultStrategies;

public class Format2024DecryptorStrategy(
    JsonNode rootNode,
    BitwardenSecrets secrets,
    CommandLineOptions options,
    VaultItemDecryptor vaultItemDecryptor) : IVaultDecryptorStrategy
{
    public JsonObject Decrypt()
    {
        JsonObject decryptedEntries = [];

        DecryptAndStoreOrganizationKeys();

        string[] groupsToProcess = ["folder_folders", "ciphers_ciphers", "collection_collections", "organizations_organizations"];

        foreach (string groupKey in groupsToProcess)
        {
            JsonObject? groupDataNode = rootNode[$"user_{options.AccountUuid}_{groupKey}"]?.AsObject();
            if (groupDataNode == null) continue;

            JsonArray itemsArray = [];
            foreach (var itemKvp in groupDataNode)
            {
                if (itemKvp.Value is JsonObject itemObj)
                {
                    itemsArray.Add(vaultItemDecryptor.ProcessGroupItem(itemObj.DeepClone()));
                }
                else if (itemKvp.Value is JsonArray itemArr)
                {
                    foreach (JsonNode? node in itemArr)
                    {
                        if (node is JsonObject obj)
                        {
                            itemsArray.Add(vaultItemDecryptor.ProcessGroupItem(obj.DeepClone()));
                        }
                    }
                }
            }
            string outputKey = groupKey.Replace("_folders", "s").Replace("ciphers_ciphers", "items").Replace("_collections", "s").Replace("_organizations", "s");
            decryptedEntries[outputKey] = itemsArray;
        }

        if (options.IncludeSends)
        {
            ProcessSends(decryptedEntries);
        }

        return decryptedEntries;
    }

    private void DecryptAndStoreOrganizationKeys()
    {
        if (rootNode[$"user_{options.AccountUuid}_crypto_organizationKeys"] is not JsonObject orgKeysNode || secrets.RsaPrivateKeyDer is null)
        {
            return;
        }

        foreach (KeyValuePair<string, JsonNode?> kvp in orgKeysNode)
        {
            string? orgKeyCipher = kvp.Value?["key"]?.GetValue<string>() ?? kvp.Value?.GetValue<string>();
            if (orgKeyCipher == null) continue;

            byte[]? decryptedOrgKey = vaultItemDecryptor.DecryptRsaInternal(orgKeyCipher);
            if (decryptedOrgKey != null) secrets.OrganizationKeys[kvp.Key] = decryptedOrgKey;
        }
    }

    private void ProcessSends(JsonObject decryptedEntries)
    {
        if (rootNode[$"user_{options.AccountUuid}_encryptedSend_sendUserEncrypted"] is not JsonObject sendsDataNode)
        {
            return;
        }

        JsonArray sendsArray = [];
        foreach (KeyValuePair<string, JsonNode?> itemKvp in sendsDataNode)
        {
            if (itemKvp.Value is JsonObject itemObj)
            {
                sendsArray.Add(vaultItemDecryptor.DecryptSend(itemObj.DeepClone()));
            }
        }
        decryptedEntries["sends"] = sendsArray;
    }
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\BitwardenDecrypt\BitwardenDecrypt\Source\Decryptors\VaultStrategies\IVaultDecryptorStrategy.cs">
using System.Text.Json.Nodes;

namespace BitwardenDecryptor.Core.VaultStrategies;

public interface IVaultDecryptorStrategy
{
    JsonObject Decrypt();
}
</file>

<file path="D:\Parsa Stuff\Visual Studio\BitwardenDecrypt\BitwardenDecrypt\Source\Decryptors\VaultStrategies\LegacyJsonDecryptorStrategy.cs">
using System.Text.Json.Nodes;
using BitwardenDecryptor.Models;

namespace BitwardenDecryptor.Core.VaultStrategies;

public class LegacyJsonDecryptorStrategy(
    JsonNode rootNode,
    BitwardenSecrets secrets,
    CommandLineOptions options,
    VaultItemDecryptor vaultItemDecryptor) : IVaultDecryptorStrategy
{
    public JsonObject Decrypt()
    {
        JsonNode accountNode;
        if (options.FileFormat == "NEW")
        {
            accountNode = rootNode[options.AccountUuid!]!;
            DecryptAndStoreOrganizationKeys(accountNode["keys"]?["organizationKeys"]?["encrypted"]?.AsObject());
        }
        else // OLD format
        {
            accountNode = rootNode;
            DecryptAndStoreOrganizationKeys(accountNode["encOrgKeys"]?.AsObject());
        }

        if ((options.FileFormat == "NEW" ? accountNode["data"] : accountNode) is not JsonObject dataContainerNode)
        {
            Console.Error.WriteLine("ERROR: Data container not found in JSON.");
            Environment.Exit(1);
            return [];
        }

        JsonObject decryptedEntries = [];
        foreach (KeyValuePair<string, JsonNode?> groupKvp in dataContainerNode)
        {
            string groupKeyOriginal = groupKvp.Key;
            string outputKey = groupKeyOriginal.Contains('_') ? groupKeyOriginal[..groupKeyOriginal.IndexOf('_')] : groupKeyOriginal;
            outputKey = outputKey.Replace("ciphers", "items");

            if ((groupKeyOriginal == "sends" || (outputKey == "sends" && groupKeyOriginal.StartsWith("sends_"))) && !options.IncludeSends)
            {
                continue;
            }

            string[] supportedOutputKeys = ["folders", "items", "collections", "organizations", "sends"];
            if (!supportedOutputKeys.Contains(outputKey))
            {
                continue;
            }

            JsonNode? actualDataNode = groupKvp.Value;
            if (options.FileFormat == "NEW" && outputKey != "organizations" && outputKey != "sends" && groupKvp.Value?["encrypted"] is not null)
            {
                actualDataNode = groupKvp.Value["encrypted"];
            }

            if (actualDataNode is not JsonObject groupDataObj)
            {
                continue;
            }

            JsonArray itemsArray = [];
            foreach (KeyValuePair<string, JsonNode?> itemKvp in groupDataObj)
            {
                if (itemKvp.Value is JsonObject itemObj)
                {
                    itemsArray.Add(outputKey == "sends"
                        ? vaultItemDecryptor.DecryptSend(itemObj.DeepClone())
                        : vaultItemDecryptor.ProcessGroupItem(itemObj.DeepClone()));
                }
            }
            decryptedEntries[outputKey] = itemsArray;
        }

        return decryptedEntries;
    }

    private void DecryptAndStoreOrganizationKeys(JsonObject? orgKeysNode)
    {
        if (orgKeysNode == null || secrets.RsaPrivateKeyDer == null)
        {
            return;
        }

        foreach (KeyValuePair<string, JsonNode?> kvp in orgKeysNode)
        {
            string? orgKeyCipher = kvp.Value?["key"]?.GetValue<string>() ?? kvp.Value?.GetValue<string>();
            if (orgKeyCipher == null) continue;

            byte[]? decryptedOrgKey = vaultItemDecryptor.DecryptRsaInternal(orgKeyCipher);
            if (decryptedOrgKey != null) secrets.OrganizationKeys[kvp.Key] = decryptedOrgKey;
        }
    }
}
</file>

